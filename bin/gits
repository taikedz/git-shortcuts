#!/usr/bin/env bash

set -euo pipefail

GITS_software_version="1.2"
GITS_software_version_message="(C) Tai Kedzierski, GPLv3. https://github.com/taikedz/git-shortcuts"


### Git Shortcuts Usage:help
#
# Tool to provide shortcut commands to common onerous git operations.
#
# The tool displays the command, and executes them. To not execute the command, set `GITS_no_execute=true` in your environment
#
# Some commands (log, diff) can optionally use `less` as a pager.
# Set `GITS_use_less` environment variable to a float indicating the amount of time to sleep before activating the pager.
# Recommended values `0` (just activate pager) or `0.2` (prevent command display from bleeding into the pager session)
#
# Available commands all have their own --help section
#
# gits
#   Display short status
#
# gits fs
#   Fetch metadata, and display detailed status
#
# gits log [OPTIONS]
#   Display log, defaulting to oneline display
# 
# gits [diff] [RANGE] FILES ...
#   See file diffs
#
# gits FILES ... -m[m] [MESSAGE ...]
#   Commit/amend
#
# gits push [REMOTE [BRANCH]]
#   Push to BRANCH on REMOTE. If REMOTE or BRANCH are not declared, they will be inferred
#
# gits pull [backtrack [N]]
#   Pull changes, unless branch has diverged from upstream.
#   Optionally rollback before pulling
#
# gits gc
#   Garbage collect resources on unreachable commit paths
#
# gits profile [...]
#   Manage user.* config profiles
#
# gits version [ ls|bump [KEYWORD] ]
#   See the latest tagged version, suggest next version
#
###/doc



##bash-libs: autohelp.sh @ bf310b32 (1.4.1)

### Autohelp Usage:bbuild
#
# Autohelp provides some simple facilities for defining help as comments in your code.
# It provides several functions for printing specially formatted comment sections.
#
# Write your help as documentation comments in your script
#
# To output a named section from your script, or a file, call the
# `autohelp:print` function and it will print the help documentation
# in the current script, or specified file, to stdout
#
# A help comment looks like this:
#
#    ### <title> Usage:help
#    #
#    # <some content>
#    #
#    # end with "###/doc" on its own line (whitespaces before
#    # and after are OK)
#    #
#    ###/doc
#
# It can then be printed from the same script by simply calling
#
#   autohelp:print
#
# You can print a different section by specifying a different name
#
# 	autohelp:print section2
#
# > This would print a section defined in this way:
#
# 	### Some title Usage:section2
# 	# <some content>
# 	###/doc
#
# You can set a different comment character by setting the 'HELPCHAR' environment variable.
# Typically, you might want to print comments you set in a INI config file, for example
#
# 	HELPCHAR=";" autohelp:print help config-file.ini
# 
# Which would then find comments defined like this in `config-file.ini`:
#
#   ;;; Main config Usage:help
#   ; Help comments in a config file
#   ; may start with a different comment character
#   ;;;/doc
#
#
#
# Example usage in a multi-function script:
#
#   #!/bin/bash
#
#   ### Main help Usage:help
#   # The main help
#   ###/doc
#
#   ### Feature One Usage:feature_1
#   # Help text for the first feature
#   ###/doc
#
#   feature1() {
#       autohelp:check_section feature_1 "$@"
#       echo "Feature I"
#   }
#
#   ### Feature Two Usage:feature_2
#   # Help text for the second feature
#   ###/doc
#
#   feature2() {
#       autohelp:check_section feature_2 "$@"
#       echo "Feature II"
#   }
#
#   main() {
#       if [[ -z "$*" ]]; then
#           ### No command specified Usage:no-command
#           #No command specified. Try running with `--help`
#           ###/doc
#
#           autohelp:print no-command
#           exit 1
#       fi
#
#       case "$1" in
#       feature1|feature2)
#           "$1" "$@"            # Pass the global script arguments through
#           ;;
#       *)
#           autohelp:check "$@"  # Check if main help was asked for, if so, exits
#
#           # Main help not requested, return error
#           echo "Unknown feature"
#           exit 1
#           ;;
#       esac
#   }
#
#   main "$@"
#
###/doc

### autohelp:print [ SECTION [FILE] ] Usage:bbuild
# Print the specified section, in the specified file.
#
# If no file is specified, prints for current script file.
# If no section is specified, defaults to "help"
###/doc

HELPCHAR='#'

autohelp:print() {
    local input_line
    local section_string="${1:-}"; shift || :
    local target_file="${1:-}"; shift || :
    [[ -n "$section_string" ]] || section_string=help
    [[ -n "$target_file" ]] || target_file="$0"

    #echo -e "\n$(basename "$target_file")\n===\n"
    local sec_start='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s+(.+?)\s+Usage:'"$section_string"'\s*$'
    local sec_end='^\s*'"$HELPCHAR$HELPCHAR$HELPCHAR"'\s*/doc\s*$'
    local in_section=false

    while read input_line; do
        if [[ "$input_line" =~ $sec_start ]]; then
            in_section=true
            echo -e "\n${BASH_REMATCH[1]}\n======="

        elif [[ "$in_section" = true ]]; then
            if [[ "$input_line" =~ $sec_end ]]; then
                in_section=false
            else
                echo "$input_line" | sed -r "s/^\s*$HELPCHAR/ /;s/^  (\S)/\1/"
            fi
        fi
    done < "$target_file"

    if [[ "$in_section" = true ]]; then
            out:fail "Non-terminated help block."
    fi
}

### autohelp:paged Usage:bbuild
#
# Display the help in the pager defined in the PAGER environment variable
#
###/doc
autohelp:paged() {
    : ${PAGER=less}
    autohelp:print "$@" | $PAGER
}

### autohelp:check ARGS ... Usage:bbuild
#
# Automatically print "help" sections and exit, if "--help" is detected in arguments
#
###/doc
autohelp:check() {
    autohelp:check_section "help" "$@"
}

### autohelp:check_section SECTION ARGS ... Usage:bbuild
# Automatically print documentation for named section and exit, if "--help" is detected in arguments
#
###/doc
autohelp:check_section() {
    local section arg
    section="${1:-}"; shift || out:fail "No help section specified"

    for arg in "$@"; do
        if [[ "$arg" =~ --help ]]; then
            cols="$(tput cols)"
            autohelp:print "$section" | fold -w "$cols" -s || autohelp:print "$section"
            exit 0
        fi
    done
}
##bash-libs: tty.sh @ bf310b32 (1.4.1)

tty:is_ssh() {
    [[ -n "$SSH_TTY" ]] || [[ -n "$SSH_CLIENT" ]] || [[ "$SSH_CONNECTION" ]]
}

tty:is_pipe() {
    [[ ! -t 1 ]]
}

##bash-libs: colours.sh @ bf310b32 (1.4.1)

### Colours for terminal Usage:bbuild
# A series of shorthand colour flags for use in outputs, and functions to set your own flags.
#
# Not all terminals support all colours or modifiers.
#
# Example:
# 	
# 	echo "${CRED}Some red text ${CBBLU} some blue text. $CDEF Some text in the terminal's default colour")
#
# Preconfigured colours available:
#
# CRED, CBRED, HLRED -- red, bright red, highlight red
# CGRN, CBGRN, HLGRN -- green, bright green, highlight green
# CYEL, CBYEL, HLYEL -- yellow, bright yellow, highlight yellow
# CBLU, CBBLU, HLBLU -- blue, bright blue, highlight blue
# CPUR, CBPUR, HLPUR -- purple, bright purple, highlight purple
# CTEA, CBTEA, HLTEA -- teal, bright teal, highlight teal
# CBLA, CBBLA, HLBLA -- black, bright red, highlight red
# CWHI, CBWHI, HLWHI -- white, bright red, highlight red
#
# Modifiers available:
#
# CBON - activate bright
# CDON - activate dim
# ULON - activate underline
# RVON - activate reverse (switch foreground and background)
# SKON - activate strikethrough
# 
# Resets available:
#
# CNORM -- turn off bright or dim, without affecting other modifiers
# ULOFF -- turn off highlighting
# RVOFF -- turn off inverse
# SKOFF -- turn off strikethrough
# HLOFF -- turn off highlight
#
# CDEF -- turn off all colours and modifiers(switches to the terminal default)
#
# Note that highlight and underline must be applied or re-applied after specifying a colour.
#
# If the session is detected as being in a pipe, colours will be turned off.
#   You can override this by calling `colours:check --color=always` at the start of your script
#
###/doc

### colours:check ARGS ... Usage:bbuild
#
# Check the args to see if there's a `--color=always` or `--color=never`
#   and reload the colours appropriately
#
#   main() {
#       colours:check "$@"
#
#       echo "${CGRN}Green only in tty or if --colours=always !${CDEF}"
#   }
#
#   main "$@"
#
###/doc
colours:check() {
    if [[ "$*" =~ --color=always ]]; then
        COLOURS_ON=true
    elif [[ "$*" =~ --color=never ]]; then
        COLOURS_ON=false
    fi

    colours:define
    return 0
}

### colours:set CODE Usage:bbuild
# Set an explicit colour code - e.g.
#
#   echo "$(colours:set "33;2")Dim yellow text${CDEF}"
#
# See SGR Colours definitions
#   <https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters>
###/doc
colours:set() {
    # We use `echo -e` here rather than directly embedding a binary character
    if [[ "$COLOURS_ON" = false ]]; then
        return 0
    else
        echo -e "\033[${1}m"
    fi
}

colours:define() {

    # Shorthand colours

    export CBLA="$(colours:set "30")"
    export CRED="$(colours:set "31")"
    export CGRN="$(colours:set "32")"
    export CYEL="$(colours:set "33")"
    export CBLU="$(colours:set "34")"
    export CPUR="$(colours:set "35")"
    export CTEA="$(colours:set "36")"
    export CWHI="$(colours:set "37")"

    export CBBLA="$(colours:set "1;30")"
    export CBRED="$(colours:set "1;31")"
    export CBGRN="$(colours:set "1;32")"
    export CBYEL="$(colours:set "1;33")"
    export CBBLU="$(colours:set "1;34")"
    export CBPUR="$(colours:set "1;35")"
    export CBTEA="$(colours:set "1;36")"
    export CBWHI="$(colours:set "1;37")"

    export HLBLA="$(colours:set "40")"
    export HLRED="$(colours:set "41")"
    export HLGRN="$(colours:set "42")"
    export HLYEL="$(colours:set "43")"
    export HLBLU="$(colours:set "44")"
    export HLPUR="$(colours:set "45")"
    export HLTEA="$(colours:set "46")"
    export HLWHI="$(colours:set "47")"

    # Modifiers
    
    export CBON="$(colours:set "1")"
    export CDON="$(colours:set "2")"
    export ULON="$(colours:set "4")"
    export RVON="$(colours:set "7")"
    export SKON="$(colours:set "9")"

    # Resets

    export CBNRM="$(colours:set "22")"
    export HLOFF="$(colours:set "49")"
    export ULOFF="$(colours:set "24")"
    export RVOFF="$(colours:set "27")"
    export SKOFF="$(colours:set "29")"

    export CDEF="$(colours:set "0")"

}

colours:auto() {
    if tty:is_pipe ; then
        COLOURS_ON=false
    else
        COLOURS_ON=true
    fi

    colours:define
    return 0
}

colours:auto

##bash-libs: out.sh @ bf310b32 (1.4.1)

### Console output handlers Usage:bbuild
#
# Write data to console stderr using colouring
#
###/doc

### out:info MESSAGE Usage:bbuild
# print a green informational message to stderr
###/doc
function out:info {
    echo "$CGRN$*$CDEF" 1>&2
}

### out:warn MESSAGE Usage:bbuild
# print a yellow warning message to stderr
###/doc
function out:warn {
    echo "${CBYEL}WARN: $CYEL$*$CDEF" 1>&2
}

### out:defer MESSAGE Usage:bbuild
# Store a message in the output buffer for later use
###/doc
function out:defer {
    OUTPUT_BUFFER_defer[${#OUTPUT_BUFFER_defer[@]}]="$*"
}

# Internal
function out:buffer_initialize {
    OUTPUT_BUFFER_defer=(:)
}
out:buffer_initialize

### out:flush HANDLER ... Usage:bbuild
#
# Pass the output buffer to the command defined by HANDLER
# and empty the buffer
#
# Examples:
#
# 	out:flush echo -e
#
# 	out:flush out:warn
#
# (escaped newlines are added in the buffer, so `-e` option is
#  needed to process the escape sequences)
#
###/doc
function out:flush {
    [[ -n "$*" ]] || out:fail "Did not provide a command for buffered output\n\n${OUTPUT_BUFFER_defer[*]}"

    [[ "${#OUTPUT_BUFFER_defer[@]}" -gt 1 ]] || return 0

    for buffer_line in "${OUTPUT_BUFFER_defer[@]:1}"; do
        "$@" "$buffer_line"
    done

    out:buffer_initialize
}

### out:fail [CODE] MESSAGE Usage:bbuild
# print a red failure message to stderr and exit with CODE
# CODE must be a number
# if no code is specified, error code 127 is used
###/doc
function out:fail {
    local ERCODE=127
    local numpat='^[0-9]+$'

    if [[ "$1" =~ $numpat ]]; then
        ERCODE="$1"; shift || :
    fi

    echo "${CBRED}ERROR FAIL: $CRED$*$CDEF" 1>&2
    exit $ERCODE
}

### out:error MESSAGE Usage:bbuild
# print a red error message to stderr
#
# unlike out:fail, does not cause script exit
###/doc
function out:error {
    echo "${CBRED}ERROR: ${CRED}$*$CDEF" 1>&2
}

gits:local-help() {
    local section="$1"; shift

    if [[ "$*" =~ --help ]]; then
        autohelp:print "help-$section"
        exit 0
    fi
}

gits:local-help-noempty() {
    if [[ -z "$*" ]]; then
        autohelp:print "help-$section"
        exit 0
    fi

    gits:local-help "$@"
}

gits:current-branch() {
    git branch | grep '^*' | cut -f 2 -d' '
}

gits:remote-exists() {
    local remote_name target
    target="$1"; shift

    while read remote_name; do
        if [[ "$remote_name" = "$target" ]]; then
            return 0
        fi
    done < <(gits:run remote)

    return 1
}

gits:run() {
    local token

    echo -en "\033[30;1;43mgit " >&2
    for token in "$@"; do
        if [[ "$token" =~ " " ]]; then
            echo -n "\"$token\" " >&2
        else
            echo -n "$token " >&2
        fi
    done
    echo "$CDEF" >&2

    if gits:use_less; then
        sleep "$GITS_use_less"
    fi

    if [[ "${GITS_no_execute:-}" != true ]]; then
        if gits:use_less; then
            git "$@" | less -R
        else
            git "$@"
        fi
    fi
}

gits:use_less() {
    [[ "${GITS_use_less:-}" =~ ^[0-9.]+$ ]] && [[ "${GITS_use_less_internal:-}" = true ]]
}

gits:pager() {
    GITS_use_less_internal=true
    "$@"
    unset GITS_use_less_internal
}
##bash-libs: readkv.sh @ bf310b32 (1.4.1)

### Key Value Pair Reader Usage:bbuild
#
# Read a value given the key, from a specified file
#
###/doc

### readkv KEY FILE [DEFAULT] Usage:bbuild
#
# The KEY is the key in the file. A key is identified as starting at the beginning of a line, and ending at the first '=' character
#
# The value starts immediately after the first '=' character.
#
# If no value is found, the DEFAULT value is returned, or an empty string
#
###/doc

function readkv {
    local thedefault thekey thefile
    thekey="$1" ; shift
    thefile="$1"; shift

    if [[ -n "${1:-}" ]]; then
        thedefault="$1"; shift || :
    fi

    local res="$(readkv:meaningful_data "$thefile"|grep -E "^$thekey"'\s*='|sed -r "s/^$thekey"'\s*=\s*//')"
    if [[ -z "$res" ]]; then
        echo "${thedefault:-}"
    else
        echo "$res"
    fi
}

### readkv:require KEY FILE Usage:bbuild
#
# Like readkv, but causes a failure if the file does not exist.
#
###/doc

function readkv:require {
    if [[ -z "${2:-}" ]]; then
        out:fail "No file specified to read [$*]"
    fi

    if [[ ! -f "$2" ]] ; then
        out:fail "No such file $2 !"
    fi

    if ! head -n 1 "$2" > /dev/null; then
        out:fail "Could not read $2"
    fi
    readkv "$@"
}

### readkv:meaningful_data FILE Usage:bbuild
# Dump the file contents, stripping meaningless data (empty lines and comment lines)
###/doc
readkv:meaningful_data() {
    grep -v -P '^\s*(#.*)?$' "$1"
}
##bash-libs: ensureline.sh @ bf310b32 (1.4.1)

### ensureline Usage:bbuild
#
# Utility for manipulating config files (and other files where all similar lines need to match).
#
#    ensureline FILE PATTERN LINEDATA
#
# Ensure that **every** line in FILE matched by PATTERN becomes LINEDATA
#
# If no such line is found, LINEDATA is appended to the end of the file.
#
# For example
#
# 	ensureline /etc/ssh/sshd_config '#?PasswordAuthentication.*' "PasswordAuthentication no"
#
# Ensure that the PasswordAuthentication line, whether commented out or not,
# becomes an uncomented "PasswordAuthentication no", or add it to the end of the file.
#
# The match applies to the full line; the pattern '#?PasswordAuth' on its own would not match, due to the missing characters.
#
###/doc

function ensureline {
    local file="$1"; shift || :
    local pattern="$1"; shift || :

    if grep -P "^$pattern$" "$file" -q ; then
        ensureline:matches "$file" "$pattern" "$@"
    else
        ensureline:add "$file" "$pattern" "$@"
    fi
}

# The following functions are internal, and should not be used.
# Use the main `ensureline` instead

function ensureline:matches {
    local FILE="$1"; shift || :
    local PATTERN="$1"; shift || :
    local LINEDATA="$1"; shift || :

    #TODO - add support to specify a start line, and a range?

    sed -r "s^$PATTERN$$LINEDATA" -i "$FILE"
}

function ensureline:add {
    local FILE="$1"; shift || :
    local PATTERN="$1"; shift || :
    local LINEDATA="$1"; shift || :

    echo "$LINEDATA" >> "$FILE"
}

gits:prefs:get() {
    local prefsfile setting
    setting="${1:-}" ; shift || out:fail "No setting provided"
    prefsfile="$(gits:prefs:filepath)"

    if [[ -f "$prefsfile" ]]; then
        readkv "$setting" "$prefsfile" "$*"
    else
        [[ -z "$*" ]] || echo "$*"
    fi
}

gits:prefs:put() {
    local prefsfile setting value
    setting="${1:-}" ; shift || out:fail "No setting provided"
    value="${1:-}"; shift || out:fail "No value provided"
    prefsfile="$(gits:prefs:filepath)"

    [[ -f "$prefsfile" ]] || touch "$prefsfile"

    ensureline "$prefsfile" "$setting\s*=.*" "$setting = $value"
}

gits:prefs:filepath() {
    local searchdir
    searchdir="$PWD"

    while [[ ! -d "$searchdir/.git" ]]; do
        searchdir="$(dirname "$searchdir")"
        [[ "$searchdir" != / ]] || out:fail "'$PWD' is not in a git repository."
    done

    echo "$searchdir/.git-shortcuts"
}

gits:prefs:advise() {
    out:info "Set '$1 = $2' in .git-shortcuts to make this decision permanent."
}
gits:store:create-get-file() {
    local filepath
    filepath="$(gits:store:get-file "$1")"
    touch "$filepath" || out:fail "Could not create '$storefile'"
    echo "$filepath"
}

gits:store:get-file() {
    local storefile fsubdir fname
    fsubdir="$(dirname "$1")" || out:fail "No file specified"
    [[ "$fsubdir" != . ]] || fsubdir=""

    fname="$(basename "$1")"
    storefile="$(gits:store:get-dir "$fsubdir")/$fname"

    echo "$storefile"
}

gits:store:get-dir() {
    local storedir
    storedir="$HOME/.config/git-shortcuts/${1:-}"
    mkdir -p "$storedir"
    echo "$storedir"
}

gits:status:short() {
    local dirs=(: "$@")
    local d

    [[ -n "${dirs[@]:1}" ]] || dirs=(: .)

    for d in "${dirs[@]:1}"; do
        [[ -d "$d" ]] || continue
        (cd "$d"
        out:info "$PWD"
        gits:run status -sb -uall
        )
    done
}

gits:status:fetch() {
    local dirs=(: "$@")
    local d

    [[ -n "${dirs[@]:1}" ]] || dirs=(: .)

    for d in "${dirs[@]:1}"; do
        [[ -d "$d" ]] || continue
        (cd "$d"
        out:info "$PWD"
        gits:run fetch --all
        gits:run status -uall
        )
    done
}

### diff [RANGE] ARGUMENTS ... Usage:help-diff
#
# Display diffs in colour
#
# The RANGE option can be specified as "/" optinally followed by a first number,
#   optionally followed by another "/", optionally followed by a second number
#
# The first slash specified on its own causes the comparison to be from HEAD to current state, useful for diffing files that have been staged
#
# A subsequent first number N diffs from HEAD~$N to HEAD
#
# A subsequent second slash causes diff from HEAD~$N to current state, even if staged
#
# A final second number M causes a diff from HEAD~$N to HEAD~$M
#
# Examples:
#
# See diffs for files ; will show nothing if files are staged
#
#   gits file1 file2
#
# See diffs for staged files
#
#   gits / file1 file2
#
# See diffs from HEAD~3 to HEAD
#
#   gits /3/
#
###/doc

gits:diff() {
    gits:commit:check "$@" || {
        gits:commit "$@"
        return
    }

    local arg parameters
    parameters=(:)

    arg="${1:-}"

    gits:local-help-noempty diff "$@"

    if [[ "$arg" = / ]]; then
        shift
        parameters+=(HEAD -- "$@")
    elif [[ "$arg" =~ ^/([0-9]+)$ ]]; then
        shift
        parameters+=(HEAD~"${BASH_REMATCH[1]}" -- "$@")
    elif [[ "$arg" =~ ^/([0-9]+)/$ ]]; then
        shift
        parameters+=(HEAD~"${BASH_REMATCH[1]}" HEAD -- "$@")
    elif [[ "$arg" =~ ^/([0-9]+)/([0-9]+)$ ]]; then
        shift
        parameters+=(HEAD~"${BASH_REMATCH[1]}" HEAD~"${BASH_REMATCH[2]}" -- "$@")
    else
        parameters+=("$@")
    fi

    gits:pager gits:run diff --color "${parameters[@]:1}"
}
### gits co [ ... ] Usage:help-checkout
# Checkout shorthands
#
# `gits co`
# 
# Checkout the master branch
# 
# `gits co TARGET [OPTIONS ...]`
#
# If TARGET is an existing local or remote branch, check it out
#
# Else if TARGET is an existing path, revert the file/path
#
# Else, offer to create and checkout a new branch
#
# OPTIONS are standard options for `git checkout` such that
#
# `gits co TARGET {OPTIONS ...}` --> `git checkout {OPTIONS ...} TARGET`
###/doc

gits:checkout() {
    . <(args:use:local ?target -- "$@") ; 

    if [[ -z "$target" ]]; then
        gits:run checkout master
        return
    fi

    gits:local-help checkout "$target" "$@"

    if gits:branch:_exists "$target"; then
        gits:run checkout "$@" "$target"

    elif [[ -e "$target" ]]; then
        gits:run checkout "$@" "$target"

    else
        askuser:confirm "'$target' does not exist - create it ?"
        gits:run checkout -b "$@" "$target"
    fi
}

### gits clone URL [PATH] Usage:help-clone
#
# Clone a git URL, creating intermediary directories.
#
# If DIRECTORY is not specified:
#
# * URL is parsed assuming presence of a domain name - this is detected by a `user@domain` or `scheme://domain` pattern
# * Group/user name and repo name are detected as being at the end of the URL as `name/repo(.git)?`
#
# The clone then creates directories `domain/name/repo` and clones to it.
#
# If DIRECTORY is specified:
#
# All intermediary directories are created, then the clone is performed to that location.
#
###/doc

gits:clone:_dispatch() {
    . <(args:use:local ?url ?directory -- "$@") ; 

    gits:local-help-no-empty clone "$url" "$@"

    if [[ -z "$directory" ]]; then
        local domain user repo
        gits:clone:_valid-url "$url"
        gits:clone:get-components domain user repo "$url"

        ([[ -n "$domain" ]] && [[ -n "$user" ]] && [[ "$repo" ]]) || out:fail "Failed to parse URL"

        mkdir -p "$domain/$user"
    else
        mkdir -p "$directory"
    fi

    gits:run clone "$url" "$domain/$user/$repo"
}

gits:clone:get-components() {
    . <(args:use:local v_domain v_user v_repo url -- "$@") ; 
    local -n p_domain p_user p_repo
    p_domain=$v_domain
    p_user=$v_user
    p_repo=$v_repo

    p_domain="$(echo "$url"|sed -r -e 's#^([a-zA-Z0-9]+://)?([a-zA-Z0-9]+@)?##' -e 's#([^/:]+?).+#\1#')"
    read p_user p_repo < <(echo "$url"|sed -r -e 's#.+[:/]([^/]+)/([^/]+)(\.git)?$#\1 \2#')
}

gits:clone:_valid-url() {
    . <(args:use:local url -- "$@") ; 
    ( [[ ! "$url" =~ \.\. ]] && ([[ "$url" =~ ^[a-z]+://[a-z] ]] || [[ "$url" =~ [a-zA-Z0-9_]+@[a-zA-Z] ]]) ) || out:fail "Invalid URL requested"
}

##bash-libs: askuser.sh @ bf310b32 (1.4.1)

### askuser Usage:bbuild
# Present the user with questions on stderr
###/doc

yespat='^(yes|YES|y|Y)$'
numpat='^[0-9]+$'
rangepat='[0-9]+,[0-9]+'
listpat='^[0-9 ]+$'
blankpat='^ *$'

### askuser:confirm Usage:bbuild
# Ask the user to confirm a closed question. Defaults to no
#
# returns 0 on successfully match 'y' or 'yes'
# returns 1 otherwise
###/doc
function askuser:confirm {
    read -p "$* [y/N] > " 1>&2
    if [[ "$REPLY" =~ $yespat ]]; then
        return 0
    else
        return 1
    fi
}

### askuser:ask Usage:bbuild
# Ask the user to provide some text
#
# Echoes out the entered text
###/doc
function askuser:ask {
    read -p "$* : " 1>&2
    echo "$REPLY"
}

### askuser:password Usage:bbuild
# Ask the user to enter a password (does not echo what is typed)
#
# Echoes out the entered text
###/doc
function askuser:password {
    read -s -p "$* : " 1>&2
    echo >&2
    echo "$REPLY"
}

### askuser:choose_multi Usage:bbuild
# Allows the user to choose from multiple choices
#
# askuser:chose_multi MESG CHOICESTRING
#
#
# MESG is a single string token that will be displayed as prompt
#
# CHOICESTRING is a comma-separated, or newline separated, or "\\n"-separated token string
#
# Equivalent strings include:
#
# * `"a\\nb\\nc"` - quoted and explicit newline escapes
# * `"a,b,c"` - quoted and separated with commas
# * `a , b , c` - not quoted, separated by commas
# * `a`, `b` and `c` on their own lines
#
# User input:
#
# User can choose by selecting
#
# * a single item by number
# * a range of numbers (4,7 for range 4 to 7)
# * or a string that matches the pattern
#
# All option lines that match will be returned, one per line
#
# If the user selects nothing, then function returns 1 and an empty stdout
###/doc
function askuser:choose_multi {
    local mesg=$1; shift || :
    local choices=$(echo "$*"|sed -r 's/ *, */\n/g')

    out:info "$mesg:" 
    local choicelist="$(echo -e "$choices"|grep -E '^' -n| sed 's/:/: /')"
    echo "$choicelist" 1>&2
    
    local sel=$(askuser:ask "Choice")
    if [[ "$sel" =~ $blankpat ]]; then
        return 1

    elif [[ "$sel" =~ $numpat ]] || [[ "$sel" =~ $rangepat ]]; then
        echo -e "$choices" | sed -n "$sel p"
    
    elif [[ "$sel" =~ $listpat ]]; then
        echo "$choicelist" | grep -E "^${sel// /|}:" | sed -r 's/^[0-9]+: //'

    else
        echo -e "$choices"  |grep -E "$(echo "$sel"|tr " " '|')"
    fi
    return 0
}

### askuser:choose Usage:bbuild
# Ask the user to choose an item
#
# Like askuser:choose_multi, but will loop if the user selects more than one item
#
# If the user provides no entry, returns 1
#
# If the user chooses one item, that item is echoed to stdout
###/doc
function askuser:choose {
    local mesg=$1; shift || :
    while true; do
        local thechoice="$(askuser:choose_multi "$mesg" "$*")"
        local lines=$(echo -n "$thechoice" | grep '$' -c)
        if [[ $lines = 1 ]]; then
            echo "$thechoice"
            return 0
        elif [[ $lines = 0 ]]; then
            return 1
        else
            out:warn "Too many results"
        fi
    done
}

### Commit: gits [FILES] -m[m|/PROFILE] [MESSAGE] Usage:help-commit
#
# After a series of files, if -m or -mm are found, performs an add + commit
#
# -m adds a new commit
# -mm amends the last commit
#
# if no MESSAGE is suppplied, an editor session is started
#
# if `/PROFILE` is set, commits using user details from the relevant profile, then reverts the details
#   /PROFILE cannot be used when amending.
#
# If the current branch is master, and `allow_master_commits` in .gits-shorthands is not set,
#   then prompt the user whether to allow.
#   When set to `true`, never prompts and allows comitting to master
#   When set to `false`, never prompts and prevents comitting to master
#
###/doc

GITS_commitflag="^-m(m|/([a-zA-Z_-]+))?$"

gits:commit:check() {
    local x
    for x in "$@"; do
        if [[ "$x" =~ $GITS_commitflag ]]; then
            return 1
        elif [[ "$x" =~ ^-mm/ ]]; then
            out:warn "Amended commit: profile change will not be taken into account unless previously empty."
            sleep 1
        fi
    done

    return 0
}

gits:commit() {
    gits:local-help commit "$@"

    gits:commit:check_master

    # need to add help that does not catch --help as part of message
    local files item arguments
    files=(:)
    arguments=(:)
    item="$1"

    while [[ ! "$item" =~ $GITS_commitflag ]]; do
        files+=("$item")
        shift
        item="$1"
    done
    shift

    GITS_profile_switch="${BASH_REMATCH[2]:-}"

    if [[ "$item" =~ ^-mm ]]; then
        arguments+=(--amend)
    fi

    if [[ -n "$*" ]]; then
        arguments+=(-m "$*")
    fi

    if [[ -n "${files[*]:1}" ]]; then
        gits:run add "${files[@]:1}"
    fi

    if [[ -n "${GITS_profile_switch:-}" ]]; then
        configname="$(git config user.name)"
        configmail="$(git config user.email)"
        gits:profiles:save temp "$configname" "$configmail"
        gits:profiles:apply "$GITS_profile_switch"
    fi

    gits:run commit "${arguments[@]:1}" || :

    if [[ -n "${GITS_profile_switch:-}" ]]; then
        gits:commit:profile-restore
    fi
}

gits:commit:profile-restore() {
    gits:profiles:apply temp
}

gits:commit:check_master() {
    local onbranch allowmaster setting
    setting=allow_master_commits
    onbranch="$(git status | head -n1 | grep -oP '(?<=On branch )[^\s]+')"
    allowmaster="$(gits:prefs:get "$setting")"

    if [[ "$onbranch" = master ]]; then
        if [[ "$allowmaster" = false ]]; then
            out:fail "You must not commit on master. Try moving your changes with 'git stash' and 'git checkout' before comitting again."

        elif [[ "$allowmaster" = true ]]; then
            return 0

        else
            if askuser:confirm "${CYEL}You are comitting on master - continue ?${CDEF}"; then
                gits:prefs:advise "$setting" "true"
                return 0
            fi
            gits:prefs:advise "$setting" "false"
            out:fail "Abort"
        fi
    fi

    return 0
}
### log [OPTIONS] [FILES ...] Usage:help-log
#
# Show short log, in colour.
#
# The following option shortcuts are specific to gits:
#
# files|-f
#   Show files. Equivalent to standard option --name-only
#
# graph|-g
#   Show as graph, on a single line unless "long" is specified
#
# long|-l
#   Show long format instead of oneline format
#
# The [FILES ...] are optional, and can also be any other git-log standard options
#
###/doc

gits:log() {
    local arg
    gits:local-help log "$@"

    local options=(--color --decorate=short)
    local add_short=true

    if [[ "${1:-}" = graph ]] || [[ "${1:-}" = -g ]]; then
        options+=(--graph --all)
        shift

    fi

    for arg in "$@"; do
    case "$arg" in
    files|-f)
        options+=(--name-only)
        shift
        ;;
    graph|-g)
        options+=(--graph --all)
        shift
        ;;
    long|-l)
        add_short=false
        shift
        ;;
    *)
        break
        ;;
    esac
    done

    if [[ "$add_short" = true ]]; then
        options+=(--oneline)
    fi

    gits:pager gits:run log "${options[@]}" "$@"
}
##bash-libs: varify.sh @ bf310b32 (1.4.1)

### Varify Usage:bbuild
# Make a string into a valid variable name or file name
#
# Collapses any string of invalid characters into a single underscore
#
# For example
#
# 	varify:var "http://example.com"
#
# returns
#
# 	http_example.com
#
###/doc

### varify:var Usage:bbuild
#
# Valid characters for varify:var are:
#
# * a-z
# * A-Z
# * 0-9
# * underscore ("_")
###/doc
function varify:var {
    echo "$*" | sed -r 's/[^a-zA-Z0-9_]/_/g'
}

### varify:fil Usage:bbuild
#
# Valid characters for varify:fil are:
#
# * a-z
# * A-Z
# * 0-9
# * underscore ("_")
# * dash ("-")
# * period (".")
#
# Can be used to produce filenames.
#
###/doc
function varify:fil {
    echo "$*" | sed -r 's/[^a-zA-Z0-9_.-]/_/g'
}

### gits profile Usage:help-profile
#
# Save user/email configurations, apply them, manage them
#
# gits profile
#   Display the user name and email currently configured on the repo
#
# gits profile list
#   Display the defined profiles
#
# gits profile get PROFILE
#   Display the settings for specified profile
# 
# gits profile delete PROFILE
#   Delete a saved profile
#
# gits profile save PROFILE USER_NAME EMAIL
#   Save user name and email to the named profile
#
# gits profile apply PROFILE
#   Configure the repo to use the specified profile
#
###/doc

## todo
# gits profile profilename user.name="User Name" user.email="mail@domain.tld" diff.tool=meld comit.editor=vim
#
# save literal config names->values to the key file
# iterate over config to apply
# allow a `profile edit` command

gits:profiles:_dispatch() {
    gits:local-help profile "$@"

    local action
    if [[ -z "$*" ]]; then
        echo "Current config:"
        echo "  Name:  $(git config user.name)"
        echo "  Email: $(git config user.email)"

    else
        action="${1:-}" ; shift || :
        case "$action" in
        save|get|delete|list|apply)
            gits:profiles:"$action" "$@"
            ;;
        *)
            out:fail "Unknown action"
        esac
    fi
}

gits:profiles:get() {
    local profiled profilename
    profilename="$(varify:fil "${1:-}")"; shift || out:fail "No profile name specified"
    profilef="$(gits:store:get-file profiles/$profilename.txt)"

    [[ -f "$profilef" ]] || out:fail "No such profile '$profilename'"

    gits:profiles:display "$profilef"
}

gits:profiles:delete() {
    local profiled profilename
    profilename="$(varify:fil "${1:-}")"; shift || out:fail "No profile name specified"
    profilef="$(gits:store:get-file profiles/$profilename.txt)"

    [[ -f "$profilef" ]] || out:fail "No such profile '$profilename'"

    askuser:confirm "Delete '$profilename'?" || return
    rm "$profilef"
}

gits:profiles:display() {
    sed -r 's/^/\t/' "$1"
}

gits:profiles:apply() {
    local profiled profilename uname umail
    profilename="$(varify:fil "${1:-}")"; shift || out:fail "No profile name specified"
    profilef="$(gits:store:get-file profiles/$profilename.txt)"

    [[ -f "$profilef" ]] || out:fail "No such profile '$profilename'"

    uname="$(readkv:require Name "$profilef")" #|| out:fail "Name could not be read"
    umail="$(readkv:require Mail "$profilef")" #|| out:fail "Mail could not be read"

    gits:run config user.name "$uname"
    gits:run config user.email "$umail"
}

gits:profiles:save() {
    local profiled profilename username useremail
    profilename="$(varify:fil "${1:-}")"; shift || out:fail "No profile name specified"
    username="${1:-}"; shift || out:fail "No user name specified"
    useremail="${1:-}"; shift || out:fail "No user email specified"
    
    profilef="$(gits:store:create-get-file profiles/$profilename.txt)"
    echo -e "Name=$username\nMail=$useremail" > "$profilef"
}

gits:profiles:list() {
    local profiled pfile sname
    profiled="$(gits:store:get-dir profiles)"

    for pfile in "$profiled/"*.txt ; do
        sname="${pfile##*/}"
        sname="${sname%.*}"

        echo "$sname"
        gits:profiles:display "$pfile"
    done
}
### gits push [REMOTE [BRANCH]] Usage:help-push
#
# Push to remote; if not set, automatically guess and set upstream
#
###/doc

gits:push() {
    gits:local-help push "$@"

    local remote branch localbranch pushargs
    pushargs=(push --set-upstream)
    localbranch="$(gits:current-branch)"

    [[ -n "$localbranch" ]] || out:fail "Could not get local branch !"

    if [[ -z "$*" ]]; then
        gits:run "${pushargs[@]}" origin "$localbranch"
        return
    fi

    remote="$1"; shift

    gits:remote-exists "$remote" || out:fail "No such remote '$remote'"

    if [[ -z "$*" ]]; then
        gits:run "${pushargs[@]}" "$remote" "$localbranch"
    else
        branch="$1"; shift

        gits:run "${pushargs[@]}" "$remote" "$branch"
    fi
}
### pull [backtrack [N]] Usage:help-pull
#
# gits pull
# ---------
#
# With no options, performs a fetch and checks for fast-forwardability.
#
# If the remote branch is simply ahead, the local branch will be fast-forwarded.
#
# If the branches have diverged, no pull is performed and a warning is printed.
#
# gits pull backtrack [N]
# -----------------------
#
# If your local and remote branches have diverged due to upstream having rebased, do a backtrack.
#
#   gits pull backtrack 5
#
# revert 5 commits, then pull
#
#   gits pull backtrack
#
# reverts each commit one by one until no longer on a divergent path
#
###/doc

##bash-libs: patterns.sh @ bf310b32 (1.4.1)

### Useful patterns Usage:bbuild
#
# Some useful regex patterns, exported as environment variables.
#
# They are not foolproof, and you are encouraged to improve upon them.
#
# $PAT_blank - detects whether an entire line is empty or whitespace
# $PAT_comment - detects whether is a line is a script comment (assumes '#' as the comment marker)
# $PAT_num - detects whether the string is an integer number in its entirety
# $PAT_cvar - detects if the string is a valid C variable name
# $PAT_filename - detects if the string is a safe UNIX or Windows file name;
#   does not allow presence of whitespace or special characters aside from '_', '.', '-'
# $PAT_email - simple heuristic to determine whether a string looks like a valid email address
#
###/doc

export PAT_blank='^\s*$'
export PAT_comment='^\s*(#.*)?$'
export PAT_num='^[0-9]+$'
export PAT_cvar='^[a-zA-Z_][a-zA-Z0-9_]*$'
export PAT_filename='^[a-zA-Z0-9_.-]$'
export PAT_email="$PAT_filename@$PAT_filename.$PAT_cvar"

gits:pull:_dispatch() {
    gits:local-help pull "$@"

    local action="${1:-}" ; shift || :

    if [[ -z "$action" ]]; then
        gits:pull:checking
        return
    fi

    case "$action" in
    backtrack)
        gits:pull:backtrack "$@"
        ;;
    *)
        out:fail "No subaction specified"
        ;;
    esac
}

gits:pull:checking() {
    gits:run fetch --all
    
    if git status | grep -qP "^Changes|^Untracked"; then
        gits:run status -sb
        out:fail "Changes detected, cannot pull"

    elif git status | grep -qP "^Your branch is (up to date|up-to-date)"; then
        gits:status:short
        echo
        out:info "Everything up to date"

    elif git status | grep -qP "^Your branch.+can be fast-forwarded"; then

        gits:run pull

    elif gits:branch:show-upstream | grep -qP ' \(none\)$'; then
        out:fail "No remote detected"

    else
        gits:run status -uall
        echo
        out:fail "Unsure whether to pull yet."

    fi
}

gits:pull:backtrack() {
    local back_by="${1:-}"; shift || :
    local headnum

    if [[ -n "$back_by" ]]; then
        [[ "$back_by" =~ $PAT_num ]] || out:fail "NaN: $back_by"
        gits:run reset --hard HEAD~$back_by

    else
        while git status | grep -q diverged; do
            git reset --hard HEAD~1
        done

    fi

    headnum="$(git log --graph --oneline --all --decorate=short |grep '(HEAD ->' -n|cut -f1 -d:)"

    gits:run log --graph --oneline --all -n${headnum}

    askuser:confirm "Pull now ?" || exit 1

    gits:run pull
}
### gits gc Usage:help-gc
#
# Remove all git commits and data that cannot be reached anymore.
#
###/doc

gits:gc-full() {
    gits:local-help gc "$@"

    gits:run -c gc.reflogExpire=0 \
        -c gc.reflogExpireUnreachable=0 \
        -c gc.rerereresolved=0 \
        -c gc.rerereunresolved=0 \
        -c gc.pruneExpire=now \
        gc
}
### gits branch [all] Usage:help-branch
#
# Show information about the current branch, or all branches
#
###/doc

gits:branch:show-upstream() {
    local info
    info="$(gits:run status -sb|grep -oP '^## \K.+'|sed 's/\.\.\./ --> /')"

    if echo "$info"|grep -o ' --> ' -q ; then
        echo "$info"
    else
        echo "$info --> (none)"
    fi
}

gits:branch:show-all() {
    gits:run branch -vv
}

gits:branch:_dispatch() {
    gits:local-help branch "$@"

    if [[ -z "$*" ]]; then
        gits:branch:show-upstream
        exit
    fi

    case "$1" in
    all)
        gits:branch:show-all
        ;;
    *)
        out:fail "Unknown 'branch' sub-operation '$1'"
        ;;
    esac
}

gits:branch:_list_all() {
    (git branch -r --no-color; git branch --no-color)|sed -r 's/^[ *]*//'
}

gits:branch:_exists() {
    . <(args:use:local branch -- "$@") ; 
    gits:branch:_list_all | grep -qP "^$branch$"
}
gits:clean() {
    git clean -dfx
}
##bash-libs: git.sh @ bf310b32 (1.4.1)

### Git handlers Usage:bbuild
#
# Some handler functions wrapping git, for automation scripts that pull/update git repositories.
#
###/doc

### git:ensure URL [DIRPATH] Usage:bbuild
#
# Clone a repository, optionally to a directory path or ./<reponame> when none specified
#
# If a repository already exists here, check that the URL matches at least one remote,
#   if so, update
#   if not, return error
#
# Error codes used
# 10 - no URL
# 11 - directory exists, and is not a git repo
# 12 - directory exists, but the specified URL was not among the remotes
#
###/doc

git:clone() {
    local url dirpath reponame
    url="${1:-}"; shift || :
    [[ -n "$url" ]] || return 10

    reponame="$(basename "$url")"
    reponame="${reponame%*.git}"

    dirpath="${1:-./$reponame}"

    [[ -d "$dirpath" ]] || {
        git clone "$url" "$dirpath"
        return "$?"
    }

    [[ -d "$dirpath/.git" ]] || {
        return 11
    }

    ( cd "$dirpath" ; git remote -v | grep "$url" -q ) || {
        return 12
    }

    ( cd "$dirpath" ; git:update master )
}

### git:update [BRANCH [REMOTE] ] Usage:bbuild
#
# Check out a branch (default master), stashing if needed, and pull the latest changes from remote (default origin)
#
# 10 - Untracked files present; cannot stash, cannot pull
# 11 - stash failed
# 12 - no remotes
#
###/doc

git:update() {
    local status_string branch remote

    branch="${1:-master}"; shift || :
    remote="${1:-origin}"; shift || :

    [[ $(git remote -v | wc -l | cut -d' ' -f2) -gt 0 ]] || return 12

    status_string="$(git status)"
    if ! ( echo "$status_string" | grep "working tree clean" -iq ) ; then
        if echo "$status_string" | grep -e "^Untracked files:" -q ; then return 10 ; fi

        git stash || return 11
    fi

    git pull "$remote" "$branch" || return 12
}

### git:last_tagged_version Usage:bbuild
#
# Look through history of the current branch and find the latest version tag
#
# If a version is found, that version is echoed, with a prefix:
#
# * "=" if the current commit is tagged with the latest version found
# * ">" if the current commit is later than the latest version found
#
# If no version is round, returns with status 1
#
###/doc

git:last_tagged_version() {
    local tagpat='(?<=tag: )([vV]\.?)?[0-9.]+'
    local tagged_version
    tagged_version="$(git log --oneline -n 1 --format="%d" | grep -oP "$tagpat")" || :

    if [[ -z "$tagged_version" ]]; then
        tagged_version="$(git log --format="%d"|grep -vP '^\s*$' | grep -oP "$tagpat" -m 1)" || :
        if [[ -z "$tagged_version" ]]; then
            return 1
        fi

        tagged_version=">$tagged_version"
    else
        tagged_version="=$tagged_version"
    fi

    echo "$tagged_version"
}

##bash-libs: version.sh @ bf310b32 (1.4.1)

### Version Tool Usage:bbuild
#
# Functions for handling version numbers.
#
# We assume sem-ver versioning, consisting of
#
# 	x.y.z
#
# where `x` is more significant than `y`, more significant in turn than `z`
#
# All parts must be present. If comparing a version string "2.3", write it as "2.3.0"
#
###/doc

### version:gt VERSIONSTRING1 VERSIONSTRING2 Usage:bbuild
#
# Returns 0 if VERSIONSTRING1 is strictly greater than VERSIONSTRING2
#
###/doc

version:gt() {
    local version1="$1"; shift || :
    local version2="$1"; shift || :

    version1="$(version:validate "$version1")" || return 1
    version2="$(version:validate "$version2")" || return 1

    read v1x v1y v1z < <(echo "$version1"|sed 's/\./ /g')
    read v2x v2y v2z < <(echo "$version2"|sed 's/\./ /g')

    # if lesser fail, if greater succeed, if equal, check minor
    [[ "$v1x" -gt "$v2x" ]] && return 0 || :
    [[ "$v1x" -lt "$v2x" ]] && return 1 || :

    [[ "$v1y" -gt "$v2y" ]] && return 0 || :
    [[ "$v1y" -lt "$v2y" ]] && return 1 || :

    # At this point, equality of the patch version is also a disqualifier.
    [[ "$v1z" -gt "$v2z" ]] && return 0 || :
    [[ "$v1z" -le "$v2z" ]] && return 1 || :

}

### version:next {major|minor|patch} VERSIONSTRING Usage:bbuild
#
# Bump the relevant version number.
#
###/doc

version:next() {
    local vsection="$1"; shift || :
    local sversion="$1"; shift || :

    version="$(version:validate "$sversion")" || return 1

    read vx vy vz < <(echo "$sversion"|sed 's/\./ /g')

    case "$vsection" in
    major)
        vx=$((vx+1))
        vy=0
        vz=0
        ;;
    minor)
        vy=$((vy+1))
        vz=0
        ;;
    patch)
        vz=$((vz+1)) ;;
    *)
        return 1
        ;;
    esac

    echo "${vx}.${vy}.${vz}"
    return 0
}

version:validate() {
    . <(args:use:local version -- "$@") ; 
    if [[ "$version" =~ ^[0-9]+$ ]]; then
        echo "${version}.0.0"

    elif [[ "$version" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "${version}.0"

    elif [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        echo "$version"

    else
        return 1
    fi
}

##bash-libs: args.sh @ bf310b32 (1.4.1)

### args Usage:bbuild
#
# An arguments handling utility.
#
###/doc

### args:get TOKEN ARGS ... Usage:bbuild
#
# Given a TOKEN, find the argument value
#
# Typically called with the parent's arguments
#
# 	args:get --key "$@"
# 	args:get -k "$@"
#
# If TOKEN is an int, returns the argument at that index (starts at 1, negative numbers count from end backwards)
#
# If TOKEN starts with two dashes ("--"), expect the value to be supplied after an equal sign
#
# 	--token=desired_value
#
# If TOKEN starts with a single dash, and is a letter or a number, expect the value to be the following token
#
# 	-t desired_value
#
# Returns 1 if could not find anything appropriate.
#
###/doc

args:get() {
    local seek="$1"; shift || :

    if [[ "$seek" =~ $PAT_num ]]; then
        local arguments=("$@")

        # Get the index starting at 1
        local n=$((seek-1))
        # but do not affect wrap-arounds
        [[ "$n" -ge 0 ]] || n=$((n+1))

        echo "${arguments[$n]}"

    elif [[ "$seek" =~ ^--.+ ]]; then
        args:get_long "$seek" "$@"

    elif [[ "$seek" =~ ^-[a-zA-Z0-9]$ ]]; then
        args:get_short "$seek" "$@"

    else
        return 1
    fi
}

args:get_short() {
    local token="$1"; shift || :
    while [[ -n "$*" ]]; do
        local item="$1"; shift || :

        if [[ "$item" = "$token" ]]; then
            echo "$1"
            return 0
        fi
    done
    return 1
}

args:get_long() {
    local token="$1"; shift || :
    local tokenpat="^$token=(.*)$"

    for item in "$@"; do
        if [[ "$item" =~ $tokenpat ]]; then
            echo "${BASH_REMATCH[1]}"
            return 0
        fi
    done
    return 1
}

### args:has TOKEN ARGS ... Usage:bbuild
#
# Determines whether TOKEN is present on its own in ARGS
#
# Typically called with the parent's arguments
#
# 	args:has thing "$@"
#
# Returns 0 on success for example
#
# 	args:has thing "one" "thing" "or" "another"
#
# Returns 1 on failure for example
#
# 	args:has thing "one thing" "or another"
#
# "one thing" is not a valid match for "thing" as a token.
#
###/doc

args:has() {
    local token="$1"; shift || :
    for item in "$@"; do
        if [[ "$token" = "$item" ]]; then
            return 0
        fi
    done
    return 1
}

### args:after TOKEN ARGS ... Usage:bbuild
#
# Return all tokens after TOKEN via the RETARR_ARGSAFTER
#
#    myargs=(one two -- three "four and" five)
# 	args:after -- "${myargs[@]}"
#
# 	for a in "${RETARR_ARGSAFTER}"; do
# 		echo "$a"
# 	done
#
# The above prints
#
# 	three
# 	four and
# 	five
#
###/doc

args:after() {
    local token="$1"; shift || :
    
    local current_token="$1"; shift || :
    while [[ "$#" -gt 0 ]] && [[ "$current_token" != "$token" ]]; do
        current_token="$1"; shift || :
    done

    RETARR_ARGSAFTER=("$@")
}

### args:use ARGNAMES ... -- ARGVALUES ... Usage:bbuild
# 
# Consume arguments into named global variables.
#
# If not enough argument values are found, the first named variable that failed to be assigned is printed as error
#
# ARGNAMES prefixed with '?' do not trigger an error
#
# Example:
#
#   #%include out.sh
#   #%include args.sh
#
#   get_parameters() {
#       . <(args:use INFILE OUTFILE ?comment -- "$@")
#
#       [[ -f "$INFILE" ]]  || out:fail "Input file '$INFILE' does not exist"
#       [[ -f "$OUTFILE" ]] || out:fail "Output file '$OUTFILE' does not exist"
#
#       [[ -z "$comment" ]] || echo "Note: $comment"
#   }
#
#   main() {
#       get_parameters "$@"
#
#       echo "$INFILE will be converted to $OUTFILE"
#   }
#
#   main "$@"
#
###/doc
args:use() {
    local argname arglist undef_f
    arglist=(:)
    for argname in "$@"; do
        [[ "$argname" != -- ]] || break
        [[ "$argname" =~ ^\??[0-9a-zA-Z_]+$ ]] || out:fail "Internal: Not a valid argument name '$argname'"

        arglist+=("$argname")
    done

    for argname in "${arglist[@]:1}"; do
        if [[ "$argname" =~ ^\? ]]; then
            argname="${argname:1}"
            undef_f=":"
        else
            undef_f="out:fail \"Internal : could not get '$argname'\""
        fi

        echo "$ARGSLIB_scope $argname=\"\${1:-}\"; shift || $undef_f"
    done
}


### args:use:local ARGNAMES ... -- ARGVALUES ... Usage:bbuild
# 
# Consume arguments into named variables. You need to use process subtitution and sourcing
#   to call the function, so that it affects the scope in your function.
#
# If not enough argument values are found, the named variable that failed to be assigned is printed as error
#
# Example:
#
#   #%include out.sh
#   #%include args.sh
#
#   person() {
#       . <(args:use:local name email -- "$@")
#
#       echo "$name <$email>"
#
#       # $1 and $2 have been consumed into $name and $email
#       # The rest remains available in $* :
#       
#       echo "Additional notes: $*"
#   }
#
#   person "Jo Smith" "jsmith@exam0ple.com" Some details
#
###/doc
args:use:local() {
    ARGSLIB_scope=local args:use "$@"
}

### version (ls|bump KEYWORD) Usage:help-version
#
# Get the last tagged version from git history, or suggest the next version
#
# Expects numerical version tags, separated with periods. May have a leading "v"
# e.g. `1.3.2`
#
# `ls`
#   Simply print the last version found in the tags of the branch's history
#
# `bump KEYWORD`
#   Use a keyword to suggest what the next version should be. The keywords available are
#
#   "patch", "fix", "bugfix" --> bump of patch-level version (3rd digit)
#
#   "fetaure", "minor"  --> bump of the minor version number (2nd digit)
#
#   "breaking", "major" --> bump of the major version number (1st digit)
#
###/doc

gits:version:get() {
    local version
    version="$(git:last_tagged_version)" || out:fail "No versions in history"

    out:info "Last version was ${version:1}"
}

gits:version:suggest() {
    . <(args:use:local keyword -- "$@") ; 
    local version
    version="$(git:last_tagged_version)" || {
        out:info "No versions found. Suggestion: 0.1"
        exit 0
    }

    version="${version:1}" # blat the indicator

    if [[ "$version" =~ ^v ]]; then
        version="${version:1}"
    fi

    case "$keyword" in
        patch|bugfix|fix)
            keyword=patch
            ;;
        feature|minor)
            keyword=minor
            ;;
        breaking|major)
            keyword=major
            ;;
        *)
            out:fail "Not a valid keyword '$keyword'"
            ;;
    esac

    out:info "Suggest: $(version:next "$keyword" "$version")"
    if [[ "$(gits:current-branch)" != master ]]; then
        out:warn "Not on master"
    fi
}

gits:version:_dispatch() {
    . <(args:use:local ?action -- "$@") ; 
    gits:local-help version "$action" "$@"

    [[ -n "$action" ]] || {
        gits:version:get
        exit
    }

    case "$action" in
    ls)
        gits:version:get
        ;;
    bump)
        gits:version:suggest "$@"
        ;;
    *)
        out:fail "Invalid action '$action'. Try --help"
        ;;
    esac
}

### remote [ACTION ...] Usage:help-remote
#
# Display data for remotes, or perfrom rename/assignment options
#
# gits remote ls
#   list remotes and their URLs
#
# gits remote set REMOTE URL
#   Assign URL to REMOTE
#   If the remote does not exist, user is prompted before creating it.
#
# gits remote sub REMOTE SUBSTITUTION ...
#   perform a substitution SUBSTITUTION on remote REMOTE
#   SUBSTITUTION is a `sed` substitution string
#   E.g. : gits remote sub origin "s|github.com/me|gitlab.com/myself|"
#
###/doc

gits:remote:_dispatch() {
    . <(args:use:local ?action -- "$@") ; 
    gits:local-help remote "$action" "$@"

    [[ -n "$action" ]] || {
        gits:remote:list
        exit
    }

    case "$action" in
    ls|list)
        gits:remote:list
        ;;
    sub)
        gits:remote:sub "$@"
        ;;
    set|set-url)
        gits:remote:set-url "$@"
        ;;
    esac
}

gits:remote:sub() {
    . <(args:use:local remote sub -- "$@") ; 
    local remote_url

    remote_url="$(git remote get-url "$remote")"
    [[ -n "$remote_url" ]] || out:fail "No URL for '$remote'"

    gits:run remote set-url "$remote" "$(echo "$remote_url"|sed -r -e "$sub")"
}

gits:remote:list() {
    git remote | while read remote; do
        echo "$remote : $(git remote get-url "$remote")"
    done
}

gits:remote:set-url() {
    . <(args:use:local remote url -- "$@") ; 
    if git remote | grep -Eq "^$remote$" ; then
        gits:run remote set-url "$remote" "$url"
    else
        askuser:confirm "Create new remote '$remote' poitning to '$url' ?" || exit
        gits:run remote add "$remote" "$url"
    fi
}

gits:main() {

    local action

    action="${1:-}"; shift || :

    [[ -n "$action" ]] || {
        gits:status:short
        echo
        out:info "${CBBLU}(see also: gits fs)"
        exit
    }

    case "$action" in
    --help)
        autohelp:print
        exit 0
        ;;
    --version)
        out:info "Git Shortcuts @ $GITS_software_version"
        out:info "${CGRN}$GITS_software_version_message"
        ;;
    -mm)
        gits:commit "$action" "$@"
        ;;
    help)
        autohelp:print help
        ;;
    clean)
        gits:clean "$@"
        ;;
    clone)
        gits:clone:_dispatch "$@"
        ;;
    co|checkout)
        gits:checkout "$@"
        ;;
    fs)
        gits:status:fetch "$@"
        ;;
    status)
        gits:status:short "$@"
        ;;
    log)
        gits:log "$@"
        ;;
    profile)
        gits:profiles:_dispatch "$@"
        ;;
    push)
        gits:push "$@"
        ;;
    pull)
        gits:pull:_dispatch "$@"
        ;;
    gc)
        gits:gc-full "$@"
        ;;
    branch)
        gits:branch:_dispatch "$@"
        ;;
    diff)
        gits:diff "$@"
        ;;
    remote)
        gits:remote:_dispatch "$@"
        ;;
    version)
        gits:version:_dispatch "$@"
        ;;
    *)
        gits:diff "$action" "$@"
        ;;
    esac
}

gits:main "$@"
